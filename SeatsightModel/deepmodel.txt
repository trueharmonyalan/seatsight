file structure

SeatsightModel
SeatsightModel/app_server.py
SeatsightModel/best.pt
SeatsightModel/camera.py
SeatsightModel/controller.py
SeatsightModel/db_manager.py
SeatsightModel/dynamic_config.py
SeatsightModel/main.py
SeatsightModel/model_runner.py
SeatsightModel/restaurant_poller.py
SeatsightModel/restaurant_session.py
SeatsightModel/seat_tracker.py
SeatsightModel/seatsight_controller.log



------------------------------
app_server.py

from flask import Flask, request, jsonify
import logging
import threading

# Set up logger
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)

# Reference to the controller (will be set in main)
controller = None

@app.route('/update-restaurant', methods=['POST'])
def update_restaurant():
    """
    Endpoint that the Node.js API will call when it receives a restaurant ID.
    Expected JSON payload: {"restaurant_id": 123}
    """
    try:
        data = request.json
        if not data or 'restaurant_id' not in data:
            logger.warning("Received invalid request - missing restaurant_id")
            return jsonify({"status": "error", "message": "Missing restaurant_id"}), 400
        
        restaurant_id = data['restaurant_id']
        
        if not restaurant_id or not str(restaurant_id).isdigit():
            logger.warning(f"Received invalid restaurant_id: {restaurant_id}")
            return jsonify({"status": "error", "message": "Invalid restaurant_id"}), 400
            
        logger.info(f"Received request to update restaurant ID to: {restaurant_id}")
        
        # Check if controller is ready
        global controller
        if not controller:
            logger.error("Controller not initialized yet")
            return jsonify({"status": "error", "message": "System not ready"}), 503
            
        # Process the restaurant ID
        success = controller.process_restaurant_id(int(restaurant_id))
        
        if success:
            return jsonify({"status": "success", "message": f"Processing restaurant ID: {restaurant_id}"}), 200
        else:
            return jsonify({"status": "error", "message": "Failed to process restaurant ID"}), 500
            
    except Exception as e:
        logger.error(f"Error processing update-restaurant request: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/status', methods=['GET'])
def status():
    """Simple endpoint to check if the service is running."""
    global controller
    if not controller:
        return jsonify({"status": "initializing", "message": "System starting up"}), 200
        
    active_sessions = controller.get_active_sessions() if controller else []
    
    return jsonify({
        "status": "ready",
        "message": "System running",
        "active_sessions": active_sessions
    }), 200

def start_server(host='0.0.0.0', port=5000):
    """Start the Flask server in a separate thread."""
    server_thread = threading.Thread(
        target=lambda: app.run(host=host, port=port, debug=False, use_reloader=False),
        daemon=True
    )
    server_thread.start()
    logger.info(f"API server started on {host}:{port}")
    return server_thread


------------------------------
camera.py

import cv2
import threading
import time
import queue
import logging
import numpy as np
from datetime import datetime

logger = logging.getLogger(__name__)

class CaptureThread(threading.Thread):
    """
    Thread to continuously capture frames from a camera or video source.
    """
    
    def __init__(self, source, queue_size=30, name=None, target_resolution=None):
        """
        Initialize the capture thread.
        
        Args:
            source: URL or ID of the camera/video source
            queue_size: Maximum number of frames to store in the queue
            name: Thread name
            target_resolution: Optional tuple (width, height) to resize frames
        """
        super().__init__(name=name)
        self.source = source
        self.frame_queue = queue.Queue(maxsize=queue_size)
        self.running = False
        self.cap = None
        self.daemon = True
        self.logger = logging.getLogger(name if name else __name__)
        self.fps = 0
        self.last_frame_time = None
        self.frame_count = 0
        
        # Set target resolution for resize
        if target_resolution:
            self.target_width, self.target_height = target_resolution
            self.logger.info(f"Will resize frames to: {self.target_width}x{self.target_height}")
        else:
            self.target_width, self.target_height = None, None
        
    def start(self):
        """Start the capture thread."""
        self.running = True
        super().start()
        
    def stop(self):
        """Stop the capture thread."""
        self.running = False
        if self.cap:
            self.cap.release()
        
    def run(self):
        """Main thread function to capture frames."""
        self.logger.info(f"Starting capture from source: {self.source}")
        
        # Try to connect to the camera
        try:
            if isinstance(self.source, str) and 'rtsp://' in self.source:
                self.logger.info(f"Opening RTSP stream: {self.source}")
                # Use UDP transport for RTSP streams
                self.cap = cv2.VideoCapture(self.source, cv2.CAP_FFMPEG)
            else:
                self.logger.info(f"Opening camera/video: {self.source}")
                self.cap = cv2.VideoCapture(self.source)
            
            if not self.cap.isOpened():
                self.logger.error(f"Failed to open video source: {self.source}")
                self.running = False
                return
                
            self.logger.info("Video source opened successfully")
            
            # Get original resolution and FPS
            orig_width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
            orig_height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            src_fps = self.cap.get(cv2.CAP_PROP_FPS)
            self.logger.info(f"Source resolution: {orig_width}x{orig_height}, FPS: {src_fps}")
            
            # Set buffer size
            self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 3)
            
            # Main capture loop
            frame_count = 0
            last_log_time = time.time()
            start_time = time.time()
            
            while self.running:
                ret, frame = self.cap.read()
                
                if not ret:
                    self.logger.warning("Failed to read frame, reconnecting...")
                    # Try to reconnect
                    self.cap.release()
                    time.sleep(2)
                    self.cap = cv2.VideoCapture(self.source)
                    if not self.cap.isOpened():
                        self.logger.error("Failed to reconnect to video source")
                        time.sleep(5)  # Wait before trying again
                    continue
                
                # Resize frame to lower resolution immediately to save processing power
                if self.target_width and self.target_height:
                    frame = cv2.resize(frame, (self.target_width, self.target_height), 
                                       interpolation=cv2.INTER_AREA)
                
                # Calculate actual FPS
                frame_count += 1
                now = time.time()
                self.last_frame_time = now
                
                # Log FPS every 5 seconds
                if now - last_log_time >= 5.0:
                    elapsed = now - last_log_time
                    self.fps = frame_count / elapsed
                    self.logger.debug(f"Capture FPS: {self.fps:.1f}")
                    last_log_time = now
                    frame_count = 0
                
                # Add timestamp to the frame
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                cv2.putText(frame, timestamp, (10, 30), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                
                # Add frame to queue, dropping old frames if full
                try:
                    self.frame_queue.put(frame, block=False)
                except queue.Full:
                    # Queue is full, get a frame to make room
                    try:
                        self.frame_queue.get_nowait()
                        self.frame_queue.put(frame, block=False)
                    except:
                        pass
                
                # Brief sleep to reduce CPU usage
                time.sleep(0.001)
                
        except Exception as e:
            self.logger.error(f"Error in capture thread: {e}")
            
        finally:
            if self.cap:
                self.cap.release()
            self.logger.info("Capture thread stopped")
    
    def get_frame(self, timeout=1.0):
        """
        Get the latest frame from the queue.
        
        Args:
            timeout: How long to wait for a frame in seconds
        
        Returns:
            Latest frame or None if queue is empty or timeout occurs
        """
        try:
            return self.frame_queue.get(timeout=timeout)
        except queue.Empty:
            return None

class VideoProcessor:
    """
    Handles video processing operations including capturing, processing, and displaying.
    """
    
    def __init__(self, source, process_every_n=1, resolution=None):
        """
        Initialize the video processor.
        
        Args:
            source: Camera URL or device ID
            process_every_n: Process every Nth frame to reduce load
            resolution: Target resolution (width, height) or None for source resolution
        """
        self.source = source
        self.process_every_n = process_every_n
        self.resolution = resolution
        self.is_running = False
        self.frame_count = 0
        self.last_processed_frame = None
        self.last_processed_time = 0
        self.fps = 0
        self.logger = logging.getLogger(__name__)
        self.capture_thread = None
        
    def start(self):
        """Start video capture and processing."""
        if self.is_running:
            return
            
        self.is_running = True
        self.logger.info(f"Starting video processor for source: {self.source}")
        
        # Create and start the capture thread with target resolution
        self.capture_thread = CaptureThread(
            source=self.source,
            queue_size=30,
            name=f"CaptureThread_{self.source}",
            target_resolution=self.resolution  # Pass resolution here
        )
        self.capture_thread.start()
        
    def stop(self):
        """Stop video capture and processing."""
        if not self.is_running:
            return
            
        self.is_running = False
        self.logger.info("Stopping video processor")
        
        if self.capture_thread:
            self.capture_thread.stop()
            self.capture_thread.join(timeout=2.0)
            
    def get_frame(self):
        """
        Get the latest frame from the capture thread.
        
        Returns:
            Latest frame or None
        """
        if not self.capture_thread:
            return None
            
        return self.capture_thread.get_frame()
    
    def should_process_frame(self):
        """
        Determine if the current frame should be processed based on the skip count.
        
        Returns:
            bool: True if the current frame should be processed
        """
        self.frame_count += 1
        return self.frame_count % self.process_every_n == 0

------------------------------
controller.py

import logging
import threading
import time
import sys
from restaurant_session import RestaurantSessionManager
from dynamic_config import DynamicConfigManager

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('seatsight_controller.log'),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger("SeatSightController")

class SeatSightController:
    """
    Main controller for the SeatSight system.
    Coordinates API polling, configuration management, and restaurant sessions.
    """
    
    def __init__(self, base_api_endpoint, db_conn_str, polling_interval=60):
        """
        Initialize the SeatSight controller.
        
        Args:
            base_api_endpoint (str): Base API endpoint for restaurant data
            db_conn_str (str): Database connection string
            polling_interval (int): How often to poll in seconds
        """
        self.base_api_endpoint = base_api_endpoint
        self.db_conn_str = db_conn_str
        self.polling_interval = polling_interval
        self.running = False
        
        # Create component instances
        self.config_manager = DynamicConfigManager(db_conn_str)
        self.session_manager = RestaurantSessionManager(db_conn_str)
    
    def start(self):
        """Start the SeatSight controller."""
        if self.running:
            logger.warning("Controller already running")
            return
        
        logger.info("Starting SeatSight controller")
        self.running = True
        logger.info("SeatSight controller started")
    
    def stop(self):
        """Stop the SeatSight controller and all managed services."""
        if not self.running:
            return
        
        logger.info("Stopping SeatSight controller")
        self.running = False
        
        # Stop all restaurant sessions
        self.session_manager.stop_all_sessions()
        
        logger.info("SeatSight controller stopped")
    
    def process_restaurant_id(self, restaurant_id):
        """
        Process a new restaurant ID received from the API.
        
        Args:
            restaurant_id: The restaurant ID to process
            
        Returns:
            bool: True if processing started successfully, False otherwise
        """
        try:
            logger.info(f"Processing restaurant ID: {restaurant_id}")
            
            # Load restaurant configuration
            config = self.config_manager.load_restaurant_config(restaurant_id)
            if not config:
                logger.error(f"Unable to load configuration for restaurant {restaurant_id}")
                return False
            
            # Check if restaurant has a valid camera URL
            if not config.get('IP_CAMERA_URL'):
                logger.error(f"Restaurant {restaurant_id} has no camera URL. Skipping.")
                return False
            
            # Set as active restaurant in the config manager
            self.config_manager.set_active_restaurant(restaurant_id)
            
            # Stop any previously running sessions for this restaurant
            if restaurant_id in self.session_manager.get_active_sessions():
                logger.info(f"Stopping existing session for restaurant {restaurant_id}")
                self.session_manager.stop_session(restaurant_id)
            
            # Start a tracking session for this restaurant
            success = self.session_manager.start_session(restaurant_id, config)
            if success:
                logger.info(f"Successfully started tracking for restaurant {restaurant_id}")
                return True
            else:
                logger.error(f"Failed to start tracking for restaurant {restaurant_id}")
                return False
                
        except Exception as e:
            logger.error(f"Error processing restaurant ID {restaurant_id}: {e}")
            return False

    def get_active_sessions(self):
        """
        Get a list of active restaurant session IDs.
        
        Returns:
            list: List of active restaurant IDs
        """
        return self.session_manager.get_active_sessions()
------------------------------
db_manager.py


------------------------------
dynamic_config.py

import psycopg2
import logging

logger = logging.getLogger(__name__)

def get_connection(conn_str):
    """
    Establish and return a connection to the PostgreSQL database using the provided connection string.
    The connection string should include credentials along with host, port, and database name.
    """
    try:
        connection = psycopg2.connect(conn_str)
        logger.info("Database connection established.")
        return connection
    except Exception as e:
        logger.error(f"Error connecting to the database: {e}")
        raise

def update_seats_status(seat_status, restaurant_id, conn_str):
    """
    Update the seats table with the latest seat statuses for a given restaurant.
    
    For each seat from the detection, update its status and position using centroid coordinates (if available).
    It assumes that the seats already exist in the table.
    Logs details for each seat that is updated.
    """
    try:
        conn = get_connection(conn_str)
        cur = conn.cursor()
        for seat in seat_status:
            seat_number = seat["seatNumber"]
            status = seat["status"]
            # Use centroid coordinates if available; otherwise, set pos_x and pos_y to NULL.
            centroid = seat.get("centroid", (None, None))
            pos_x, pos_y = centroid if centroid is not None else (None, None)
            query = """
                UPDATE seats 
                SET status = %s, pos_x = %s, pos_y = %s 
                WHERE restaurant_id = %s AND seat_number = %s;
            """
            cur.execute(query, (status, pos_x, pos_y, restaurant_id, seat_number))
            logger.info(
                f"Updated seat[{seat_number}]: status: {status}, pos_x: {pos_x}, pos_y: {pos_y} for restaurant_id {restaurant_id}"
            )
        conn.commit()
        cur.close()
        conn.close()
        logger.info(f"Finished updating seat statuses for restaurant_id {restaurant_id}.")
    except Exception as e:
        logger.error(f"Error updating seats status: {e}")

def fetch_seats_status(restaurant_id, conn_str):
    """
    Fetch the current status of seats for the specified restaurant.
    Returns a list of dictionaries, one for each seat, with keys:
      - seat_number
      - status
      - pos_x
      - pos_y
      - updated_at
    Logs a summary including the total number of seats and each seat's number with its status.
    """
    try:
        conn = get_connection(conn_str)
        cur = conn.cursor()
        query = """
            SELECT seat_number, status, pos_x, pos_y, updated_at 
            FROM seats 
            WHERE restaurant_id = %s 
            ORDER BY seat_number;
        """
        cur.execute(query, (restaurant_id,))
        rows = cur.fetchall()
        cur.close()
        conn.close()
        results = []
        for row in rows:
            results.append({
                "seat_number": row[0],
                "status": row[1],
                "pos_x": row[2],
                "pos_y": row[3],
                "updated_at": row[4]
            })
        
        logger.info(f"Total seats for restaurant_id {restaurant_id}: {len(results)}")
        for seat in results:
            logger.info(f"seat[{seat.get('seat_number', 'unknown')}]: {seat.get('status', 'unknown')}")
        
        return results
    except Exception as e:
        logger.error(f"Error fetching seats status: {e}")
        return []

def fetch_seat_count(restaurant_id, conn_str):
    """
    Fetch the total seat count for the specified restaurant from the database.
    Returns the count as an integer.
    """
    try:
        conn = get_connection(conn_str)
        cur = conn.cursor()
        query = "SELECT COUNT(*) FROM seats WHERE restaurant_id = %s;"
        cur.execute(query, (restaurant_id,))
        count = cur.fetchone()[0]
        cur.close()
        conn.close()
        logger.info(f"Fetched total seat count for restaurant_id {restaurant_id}: {count}")
        return count
    except Exception as e:
        logger.error(f"Error fetching seat count: {e}")
        return 0
------------------------------
main.py


import logging
import os
import sys
import signal
import time
import traceback

# Set up logging immediately
logging.basicConfig(
    level=logging.DEBUG,  # Set to DEBUG to get maximum information
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)  # Log to console for immediate feedback
    ]
)

logger = logging.getLogger("SeatsightMain")
logger.info("Starting main.py - initializing...")

try:
    # Attempt to import required modules
    logger.info("Importing modules...")
    from controller import SeatSightController
    from app_server import start_server, app
    logger.info("Modules imported successfully")
except ImportError as e:
    logger.critical(f"Failed to import required modules: {e}")
    logger.critical(traceback.format_exc())
    sys.exit(1)

# Default configuration
BASE_API_ENDPOINT = "http://localhost:3001/api/restaurants"
DATABASE_URL = "postgres://postgres:postgres@localhost/server"
POLLING_INTERVAL = 60  # seconds

def signal_handler(sig, frame):
    """Handle termination signals to ensure clean shutdown."""
    logger.info("Shutting down SeatSight...")
    if hasattr(signal_handler, 'controller'):
        signal_handler.controller.stop()
    sys.exit(0)

def main():
    """Main entry point for the SeatSight application."""
    try:
        logger.info("In main function - starting SeatSight system...")
        
        # Get configuration from environment variables or use defaults
        base_api_endpoint = os.environ.get('BASE_API_ENDPOINT', BASE_API_ENDPOINT)
        db_conn_str = os.environ.get('DATABASE_URL', DATABASE_URL)
        polling_interval = int(os.environ.get('POLLING_INTERVAL', POLLING_INTERVAL))
        
        # Get API server configuration
        api_host = os.environ.get('API_HOST', '0.0.0.0')
        api_port = int(os.environ.get('API_PORT', 5000))
        
        logger.info(f"Using database: {db_conn_str}")
        logger.info(f"API server will listen on: {api_host}:{api_port}")
        
        # Initialize the controller
        logger.info("Initializing controller...")
        controller = SeatSightController(base_api_endpoint, db_conn_str, polling_interval)
        signal_handler.controller = controller  # Store for signal handler
        
        # Set the controller reference in the Flask app
        logger.info("Setting controller reference in Flask app...")
        import app_server
        app_server.controller = controller
        
        # Start the controller
        logger.info("Starting controller...")
        controller.start()
        
        # Start the API server
        logger.info("Starting API server...")
        api_thread = app_server.start_server(host=api_host, port=api_port)
        logger.info("API server started - entering main loop")
        
        # Keep the main thread alive
        while True:
            logger.debug("Main thread heartbeat")
            time.sleep(10)  # Log every 10 seconds
            
    except Exception as e:
        logger.critical(f"Fatal error in main: {e}")
        logger.critical(traceback.format_exc())
        return 1
    
    return 0

if __name__ == "__main__":
    # Register signal handlers for graceful shutdown
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    logger.info("Registered signal handlers, calling main()")
    try:
        exit_code = main()
        logger.info(f"main() returned with code {exit_code}")
        sys.exit(exit_code)
    except Exception as e:
        logger.critical(f"Uncaught exception: {e}")
        logger.critical(traceback.format_exc())
        sys.exit(1)
------------------------------
model_runner.py


import sys
import logging
from config import ConfigManager
import db_manager

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

def get_restaurant_by_ip(ip_url, db_conn_str):
    """
    Query the database to retrieve the restaurant's details based on the IP URL.
    This function assumes that the restaurants table contains columns:
    owner_id, ip_camera_url, seating_capacity.
    """
    try:
        conn = db_manager.get_connection(db_conn_str)
        cur = conn.cursor()
        query = "SELECT owner_id, seating_capacity FROM restaurants WHERE ip_camera_url = %s;"
        cur.execute(query, (ip_url,))
        result = cur.fetchone()
        cur.close()
        conn.close()
        if result:
            owner_id, seating_capacity = result
            logger.info("Found restaurant details: id=%s, seating_capacity=%s", owner_id, seating_capacity)
            return {"restaurant_id": owner_id, "seat_limit": seating_capacity}
        else:
            logger.error("No restaurant record found for IP_URL: %s", ip_url)
            return None
    except Exception as e:
        logger.error("Error fetching restaurant details: %s", str(e))
        return None

def initialize_deep_learning_model(restaurant_config):
    """
    Initialize the deep learning model (or seat tracker) using restaurant-specific configuration.
    Replace the stub below with your actual model initialization logic.
    """
    restaurant_id = restaurant_config.get("restaurant_id")
    seat_limit = restaurant_config.get("seat_limit")
    ip_url = restaurant_config.get("IP_URL")
    logger.info("Initializing model for restaurant_id: %s, seat_limit: %s, ip_url: %s", 
                restaurant_id, seat_limit, ip_url)
    # TODO: Initialize your deep learning model here.
    # For example:
    # seat_tracker = SeatTracker(restaurant_config)
    # return seat_tracker
    return None

if __name__ == "__main__":
    # Load configuration using ConfigManager from config.py
    config_manager = ConfigManager("config.ini")
    
    # Read values from the configuration file.
    ip_url = config_manager.get("FALLBACK_CAMERA_URL")   # or use a key like 'IP_URL' if defined in your config.ini.
    db_conn_str = config_manager.get("DATABASE_URL")
    
    if not ip_url or not db_conn_str:
        logger.error("Both IP_URL (or FALLBACK_CAMERA_URL) and DATABASE_URL must be configured in config.ini.")
        sys.exit(1)
    
    # Query the database for additional restaurant details based on the IP URL.
    restaurant_data = get_restaurant_by_ip(ip_url, db_conn_str)
    if restaurant_data is None:
        logger.error("Failed to retrieve restaurant configuration. Exiting.")
        sys.exit(1)
    
    # Update config with dynamic details fetched from the database.
    config_manager.config['DEFAULT']['RESTAURANT_ID'] = str(restaurant_data["restaurant_id"])
    config_manager.config['DEFAULT']['SEAT_LIMIT'] = str(restaurant_data["seat_limit"])
    
    # Merge necessary configuration values for model initialization.
    restaurant_config = {
        "restaurant_id": restaurant_data["restaurant_id"],
        "seat_limit": restaurant_data["seat_limit"],
        "IP_URL": ip_url,
        "DATABASE_URL": db_conn_str
    }
    
    # Initialize the deep learning model with the updated configuration.
    initialize_deep_learning_model(restaurant_config)
------------------------------
restaurant_poller.py

import requests
import threading
import time
import logging
import json
import os

logger = logging.getLogger(__name__)

class RestaurantPoller:
    """
    A background service that periodically checks for restaurant IDs to track
    from either a file, environment variable, or manual input.
    """
    
    def __init__(self, base_api_endpoint, polling_interval=60, callback=None):
        """
        Initialize the RestaurantPoller.
        
        Args:
            base_api_endpoint (str): The base API URL (e.g., "http://localhost:3001/api/restaurants")
            polling_interval (int): How often to check for ID changes in seconds
            callback (function): Function to call when new restaurant data is detected
        """
        self.base_api_endpoint = base_api_endpoint
        self.polling_interval = polling_interval
        self.callback = callback
        self.current_restaurant_id = None
        self.running = False
        self.polling_thread = None
        self.logger = logging.getLogger(__name__)
        
        # File to store/read the current restaurant ID
        self.id_file_path = "current_restaurant_id.txt"
    
    def start(self):
        """Start the polling service in a background thread."""
        if self.running:
            self.logger.warning("RestaurantPoller already running")
            return
            
        self.running = True
        self.polling_thread = threading.Thread(target=self._polling_loop, daemon=True)
        self.polling_thread.start()
        self.logger.info("RestaurantPoller started")
    
    def stop(self):
        """Stop the polling service."""
        self.running = False
        if self.polling_thread:
            self.polling_thread.join(timeout=2.0)
        self.logger.info("RestaurantPoller stopped")
    
    def _polling_loop(self):
        """Main polling loop that runs in a background thread."""
        while self.running:
            try:
                # Check for restaurant ID from various sources
                self._check_for_restaurant_id_change()
            except Exception as e:
                self.logger.error(f"Error checking for restaurant ID changes: {e}")
            
            # Wait for next polling interval
            time.sleep(self.polling_interval)
    
    def _check_for_restaurant_id_change(self):
        """Check for changes in the restaurant ID from various sources."""
        # Priority for ID source:
        # 1. Environment variable
        # 2. File on disk
        # 3. Keep current ID if already set
        
        # Check environment variable first
        env_id = os.environ.get("SEATSIGHT_RESTAURANT_ID")
        if env_id and env_id.isdigit():
            new_id = int(env_id)
            if new_id != self.current_restaurant_id:
                self.logger.info(f"Restaurant ID from environment: {new_id}")
                self._process_new_restaurant_id(new_id)
                return
        
        # Then check the file
        try:
            if os.path.exists(self.id_file_path):
                with open(self.id_file_path, 'r') as f:
                    content = f.read().strip()
                    if content and content.isdigit():
                        new_id = int(content)
                        if new_id != self.current_restaurant_id:
                            self.logger.info(f"Restaurant ID from file: {new_id}")
                            self._process_new_restaurant_id(new_id)
                            return
        except Exception as e:
            self.logger.error(f"Error reading restaurant ID file: {e}")
    
    def _process_new_restaurant_id(self, restaurant_id):
        """
        Process a newly detected restaurant ID.
        
        Args:
            restaurant_id: The new restaurant ID to track
        """
        if restaurant_id == self.current_restaurant_id:
            return
            
        self.logger.info(f"New restaurant ID to track: {restaurant_id}")
        
        # Fetch restaurant data from the API
        restaurant_data = self._fetch_restaurant_data(restaurant_id)
        
        if restaurant_data:
            # Update current ID and notify callback
            self.current_restaurant_id = restaurant_id
            if self.callback:
                self.callback(restaurant_id, restaurant_data)
        else:
            self.logger.warning(f"Could not fetch data for restaurant ID: {restaurant_id}")
    
    def _fetch_restaurant_data(self, restaurant_id):
        """
        Fetch restaurant data using ID from the API.
        
        Args:
            restaurant_id: The restaurant ID to fetch
            
        Returns:
            dict: Restaurant data or None if fetch fails
        """
        try:
            # Construct the restaurant-specific API endpoint
            endpoint = f"{self.base_api_endpoint}/get-restaurant-id/{restaurant_id}"
            
            self.logger.info(f"Fetching restaurant data from: {endpoint}")
            
            response = requests.get(endpoint, timeout=10)
            response.raise_for_status()
            
            api_data = response.json()
            self.logger.debug(f"API response: {api_data}")
            
            # The API gives us the ID, but we need to query the database for actual details
            # So we'll just return a minimal data structure here that will trigger
            # the database queries in DynamicConfigManager
            return {
                'id': restaurant_id,
                'need_db_data': True  # Flag to indicate we need to fetch more data from DB
            }
                
        except requests.exceptions.RequestException as e:
            self.logger.warning(f"Failed to fetch restaurant data: {e}")
            return None
    
    def set_restaurant_id(self, restaurant_id):
        """
        Manually set a restaurant ID to track and save it to the file.
        
        Args:
            restaurant_id: The restaurant ID to track
        """
        try:
            # Save to file for persistence
            with open(self.id_file_path, 'w') as f:
                f.write(str(restaurant_id))
            
            self.logger.info(f"Saved restaurant ID {restaurant_id} to file")
            
            # Process the new ID immediately
            self._process_new_restaurant_id(restaurant_id)
            
            return True
        except Exception as e:
            self.logger.error(f"Error saving restaurant ID to file: {e}")
            return False
------------------------------
restaurant_session.py

import logging
import threading
import time
import psycopg2
from seat_tracker import SeatTracker
from camera import VideoProcessor

logger = logging.getLogger(__name__)

class RestaurantSession:
    """
    Manages a tracking session for a specific restaurant.
    """
    
    def __init__(self, restaurant_id, config, db_conn_str):
        """
        Initialize a restaurant session.
        
        Args:
            restaurant_id: The ID of the restaurant
            config: Configuration dictionary
            db_conn_str: Database connection string
        """
        self.restaurant_id = restaurant_id
        self.config = config
        self.db_conn_str = db_conn_str
        self.running = False
        self.processing_thread = None
        self.logger = logging.getLogger(f"RestaurantSession_{restaurant_id}")
        
        # Initialize camera
        camera_url = config.get('IP_CAMERA_URL')
        if not camera_url:
            self.logger.error("No camera URL provided in configuration")
            self.video_processor = None
        else:
            self.video_processor = VideoProcessor(
                source=camera_url,
                process_every_n=config.get('PROCESS_EVERY_N_FRAMES', 30),
                resolution=config.get('FRAME_SIZE', (640, 480))
            )
        
        # Initialize seat tracker with model path
        model_path = config.get('MODEL_PATH', 'best.pt')
        self.seat_tracker = SeatTracker(model_path=model_path)
        
        # Configure seat locations
        seats = config.get('SEATS', [])
        if seats:
            self.seat_tracker.set_seat_config(seats)
        else:
            self.logger.warning("No seat configuration provided")
    
    def start(self):
        """
        Start the restaurant tracking session.
        
        Returns:
            bool: True if started successfully
        """
        if self.running:
            self.logger.info(f"Session for restaurant {self.restaurant_id} already running")
            return True
            
        try:
            self.logger.info(f"Starting session for restaurant {self.restaurant_id}")
            
            # Check if we have a camera
            if not self.video_processor:
                self.logger.error("No video processor available, cannot start session")
                return False
            
            # Start video processor
            self.video_processor.start()
            
            # Start processing thread
            self.running = True
            self.processing_thread = threading.Thread(
                target=self._processing_loop,
                name=f"ProcessingThread_{self.restaurant_id}"
            )
            self.processing_thread.daemon = True
            self.processing_thread.start()
            
            self.logger.info(f"Restaurant session started for ID: {self.restaurant_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error starting restaurant session: {e}")
            self.running = False
            return False
    
    def stop(self):
        """Stop the restaurant tracking session."""
        if not self.running:
            return
            
        self.logger.info(f"Stopping session for restaurant {self.restaurant_id}")
        self.running = False
        
        # Stop video processor
        if self.video_processor:
            self.video_processor.stop()
            
        # Wait for processing thread to finish
        if self.processing_thread:
            self.processing_thread.join(timeout=5.0)
        
        # Clean up seat tracker
        if self.seat_tracker:
            self.seat_tracker.close()
            
        self.logger.info(f"Session for restaurant {self.restaurant_id} stopped")
    
    def _processing_loop(self):
        """Main processing loop for the restaurant session."""
        self.logger.info(f"Processing loop started for restaurant {self.restaurant_id}")
        
        last_db_update = time.time()
        db_update_interval = 10.0  # Update database every 10 seconds
        
        try:
            while self.running:
                # Get latest frame
                frame = None
                if self.video_processor:
                    frame = self.video_processor.get_frame()
                
                if frame is None:
                    self.logger.error(f"Error in processing loop: No frame available")
                    time.sleep(0.1)
                    continue
                
                # Process frame if it's time
                if self.video_processor.should_process_frame():
                    # Process frame with seat tracker
                    processed_frame, seat_status = self.seat_tracker.process_frame(frame)
                    
                    # Update database if needed
                    if seat_status and time.time() - last_db_update > db_update_interval:
                        self._update_database(seat_status)
                        last_db_update = time.time()
                
                # Add a small sleep to avoid high CPU usage
                time.sleep(0.01)
                
        except Exception as e:
            self.logger.error(f"Error in processing loop: {e}")
            
    def _update_database(self, seat_status):
        """
        Update seat status in the database.
        
        Args:
            seat_status: Dictionary of seat status updates
        """
        if not seat_status:
            return
            
        try:
            # Connect to database
            conn = psycopg2.connect(self.db_conn_str)
            cur = conn.cursor()
            
            # Update each seat status
            for seat_id, status_info in seat_status.items():
                # Convert status to database format (e.g., 'occupied' to 'unavailable')
                db_status = 'unavailable' if status_info['status'] == 'occupied' else 'available'
                
                # Update seat status in database
                cur.execute(
                    "UPDATE seats SET status = %s, last_updated = NOW() WHERE id = %s",
                    (db_status, seat_id)
                )
            
            # Commit changes
            conn.commit()
            
            # Close database connection
            cur.close()
            conn.close()
            
            self.logger.info(f"Updated {len(seat_status)} seat statuses in database")
            
        except Exception as e:
            self.logger.error(f"Error updating database: {e}")


class RestaurantSessionManager:
    """
    Manages tracking sessions for multiple restaurants.
    """
    
    def __init__(self, db_conn_str):
        """
        Initialize the session manager.
        
        Args:
            db_conn_str: Database connection string
        """
        self.db_conn_str = db_conn_str
        self.active_sessions = {}
        self.lock = threading.RLock()
        self.logger = logging.getLogger("RestaurantSessionManager")
    
    def start_session(self, restaurant_id, config):
        """
        Start a tracking session for a restaurant.
        
        Args:
            restaurant_id: The ID of the restaurant
            config: Configuration dictionary
            
        Returns:
            bool: True if session started successfully
        """
        with self.lock:
            # Check if session already exists
            if restaurant_id in self.active_sessions:
                self.logger.info(f"Session already exists for restaurant {restaurant_id}")
                return True
            
            # Create and start a new session
            self.logger.info(f"Starting new session for restaurant {restaurant_id}")
            session = RestaurantSession(restaurant_id, config, self.db_conn_str)
            success = session.start()
            
            if success:
                self.active_sessions[restaurant_id] = session
                return True
            else:
                self.logger.error(f"Failed to start session for restaurant {restaurant_id}")
                return False
    
    def stop_session(self, restaurant_id):
        """
        Stop a restaurant tracking session.
        
        Args:
            restaurant_id: The ID of the restaurant
            
        Returns:
            bool: True if session was stopped
        """
        with self.lock:
            if restaurant_id not in self.active_sessions:
                self.logger.warning(f"No active session for restaurant {restaurant_id}")
                return False
            
            session = self.active_sessions[restaurant_id]
            session.stop()
            del self.active_sessions[restaurant_id]
            self.logger.info(f"Stopped session for restaurant {restaurant_id}")
            return True
    
    def stop_all_sessions(self):
        """Stop all active restaurant sessions."""
        with self.lock:
            restaurant_ids = list(self.active_sessions.keys())
            for restaurant_id in restaurant_ids:
                self.stop_session(restaurant_id)
            self.logger.info("All sessions stopped")
    
    def get_active_sessions(self):
        """
        Get a list of active restaurant session IDs.
        
        Returns:
            list: List of active restaurant IDs
        """
        with self.lock:
            return list(self.active_sessions.keys())
------------------------------
seat_tracker.py

import cv2
import threading
import logging
from ultralytics import YOLO

class SeatTracker:
    def __init__(self, model_path='best.pt'):
        """
        Initialize SeatTracker with settings.
        Expected model classes: 'empty_seat' (mapped to 'vacant') and 'person_on_seat' (mapped to 'occupied').
        """
        self.model_path = model_path
        self.frame_size = (640, 480)  # Default, will be updated from config
        self.seat_limit = 10  # Default, will be updated from config
        self.conf_threshold = 0.5
        
        self.logger = logging.getLogger("SeatTracker")
        self.logger.setLevel(logging.INFO)
        
        # Load the YOLO model
        try:
            self.logger.info(f"Initializing SeatTracker with model: {model_path}")
            self.model = YOLO(model_path)
            self.lock = threading.Lock()
            self.seat_status = []
            
            # Map expected model classes
            self.expected_classes = {'empty_seat': 'vacant', 'person_on_seat': 'occupied'}
            self.model_class_ids = {}
            for class_id, class_name in self.model.names.items():
                name_lower = class_name.lower()
                if name_lower in self.expected_classes:
                    self.model_class_ids[class_id] = name_lower
                    self.logger.info(f"Detected model class: {class_name} (ID: {class_id})")
            if len(self.model_class_ids) < 2:
                self.logger.warning("Model may not contain both 'empty_seat' and 'person_on_seat' classes.")
                
        except Exception as e:
            self.logger.error(f"Error loading model: {e}")
            self.model = None

    def set_seat_config(self, seats):
        """
        Set the seat configuration to track.
        
        Args:
            seats: List of seat dictionaries with id, position, etc.
        """
        # Update seat limit based on config
        self.seat_limit = len(seats)
        self.logger.info(f"Set configuration for {self.seat_limit} seats")
        
        # Initialize seat status
        self.seat_status = []
        for seat in seats:
            self.seat_status.append({
                "seatNumber": seat['seat_number'],
                "status": "vacant",
                "bbox": None,
                "predicted_class": "empty_seat",
                "confidence": 0.0,
                "id": seat['id']
            })

    def process_frame(self, frame):
        """
        Process a video frame to detect seat occupancy.
        
        Args:
            frame: The video frame as a numpy array
            
        Returns:
            A copy of the frame with visualizations, and seat occupancy data
        """
        if frame is None or self.model is None:
            return frame, {}

        try:
            # Create a copy for visualization
            vis_frame = frame.copy()
            
            # Resize frame if needed
            if frame.shape[1::-1] != self.frame_size:
                frame = cv2.resize(frame, self.frame_size, interpolation=cv2.INTER_AREA)
            
            # Get predictions from the model
            results = self.model(frame, imgsz=self.frame_size, conf=self.conf_threshold, verbose=False)
            
            detections_list = []
            for box in results[0].boxes:
                cls_id = int(box.cls)
                conf = float(box.conf)
                if conf < self.conf_threshold:
                    continue
                if cls_id not in self.model_class_ids:
                    continue
                
                predicted_class = self.model_class_ids[cls_id]
                status = self.expected_classes[predicted_class]
                x1, y1, x2, y2 = map(int, box.xyxy[0].cpu().numpy())
                centroid = ((x1 + x2) // 2, (y1 + y2) // 2)
                detections_list.append({
                    "centroid": centroid,
                    "bbox": (x1, y1, x2, y2),
                    "predicted_class": predicted_class,
                    "status": status,
                    "confidence": conf
                })
            
            # Sort detections by position (top to bottom, left to right)
            detections_list.sort(key=lambda d: (d["centroid"][1], d["centroid"][0]))
            
            # Map detections to seat numbers
            mapped_seats = []
            for idx, detection in enumerate(detections_list):
                if idx >= self.seat_limit:
                    break
                detection["seatNumber"] = idx + 1
                detection["id"] = self.seat_status[idx]["id"] if idx < len(self.seat_status) else idx + 1
                mapped_seats.append(detection)
            
            # Pad with vacant seats if needed
            while len(mapped_seats) < self.seat_limit:
                seat_idx = len(mapped_seats)
                mapped_seats.append({
                    "seatNumber": seat_idx + 1,
                    "id": self.seat_status[seat_idx]["id"] if seat_idx < len(self.seat_status) else seat_idx + 1,
                    "status": "vacant",
                    "bbox": None,
                    "predicted_class": "empty_seat",
                    "confidence": 0.0
                })
            
            # Update seat status
            with self.lock:
                self.seat_status = mapped_seats
            
            # Draw visualizations
            self.draw_visualizations(vis_frame)
            
            # Display the frame if not in headless mode
            try:
                cv2.imshow("Seat Tracking", vis_frame)
                cv2.waitKey(1)
            except:
                pass
            
            # Convert to format expected by restaurant session
            seat_status_dict = {}
            for seat in self.seat_status:
                seat_id = seat["id"]
                seat_status_dict[seat_id] = {
                    'status': 'occupied' if seat["status"] == "occupied" else 'empty',
                    'confidence': seat["confidence"],
                    'class': seat["predicted_class"],
                    'seat_number': seat["seatNumber"],
                    'last_update': None  # Will be set by the session
                }
            
            return vis_frame, seat_status_dict
            
        except Exception as e:
            self.logger.error(f"Error processing frame: {e}")
            return frame, {}

    def draw_visualizations(self, frame):
        """
        Draw seat bounding boxes and labels on the frame.
        """
        try:
            for seat in self.seat_status:
                bbox = seat.get("bbox")
                if bbox:
                    x1, y1, x2, y2 = bbox
                    color = (0, 0, 255) if seat["status"] == "occupied" else (0, 255, 0)
                    cv2.rectangle(frame, (x1, y1), (x2, y2), color, 2)
                    label = f"Seat {seat['seatNumber']} : {seat['predicted_class']}"
                    cv2.putText(frame, label, (x1, y1 - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                    
            # Display summary stats
            total = self.seat_limit
            occupied = len([s for s in self.seat_status if s["status"] == "occupied"])
            vacant = total - occupied
            cv2.putText(frame, f"Occupied: {occupied}", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
            cv2.putText(frame, f"Vacant: {vacant}", (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        
        except Exception as e:
            self.logger.error(f"Error drawing visualizations: {e}")

    def get_status(self):
        """
        Return a thread-safe copy of the current seat status.
        """
        with self.lock:
            return self.seat_status.copy()
            
    def close(self):
        """
        Cleanup operations.
        """
        try:
            cv2.destroyAllWindows()
        except:
            pass
------------------------------
------------------------------




------------------------------


------------------------------




------------------------------


------------------------------




------------------------------


------------------------------